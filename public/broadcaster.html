<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>–ö–∞–º–µ—Ä–∞ –∑ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è–º</title>
  <style>
    video { width: 100%; max-width: 600px; background: black; }
    select, button {
      font-size: 1em;
      margin: 10px 5px;
      padding: 8px;
    }
  </style>
</head>
<body>
  <h2>üì∑ –ö–∞–º–µ—Ä–∞ –∑ –≤–∏–±–æ—Ä–æ–º</h2>
  <video id="localVideo" autoplay playsinline muted></video>
  <br>
  <label for="cameraSelect">üé• –û–±—Ä–∞—Ç–∏ –∫–∞–º–µ—Ä—É:</label>
  <select id="cameraSelect"></select>
  <button id="refreshBtn">üîÑ –û–Ω–æ–≤–∏—Ç–∏ —Å–ø–∏—Å–æ–∫</button>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const room = 'webrtc-room';
    const video = document.getElementById('localVideo');
    const cameraSelect = document.getElementById('cameraSelect');
    const refreshBtn = document.getElementById('refreshBtn');

    let currentStream = null;
    let pc = null;

    const config = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    socket.emit('join', room);

    async function getCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      videoDevices.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = device.label || `–ö–∞–º–µ—Ä–∞ ${cameraSelect.length + 1}`;
        cameraSelect.appendChild(option);
      });
    }

    async function startCameraById(deviceId) {
      // –ó—É–ø–∏–Ω—è—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Å—Ç—Ä—ñ–º
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }

      // –ó–∞–ø—É—Å–∫–∞—î–º–æ –Ω–æ–≤–∏–π —Å—Ç—Ä—ñ–º
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          deviceId: { exact: deviceId },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });

      currentStream = stream;
      video.srcObject = stream;

      // –Ø–∫—â–æ –±—É–≤ peerConnection - –∑–∞–∫—Ä–∏–≤–∞—î–º–æ
      if (pc) {
        pc.close();
      }

      // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π RTCPeerConnection
      pc = new RTCPeerConnection(config);

      // –î–æ–¥–∞—î–º–æ —Ç—Ä–µ–∫–∏ –¥–æ peerConnection
      stream.getTracks().forEach(track => pc.addTrack(track, stream));

      pc.onicecandidate = e => {
        if (e.candidate) socket.emit('candidate', room, e.candidate);
      };

      // –ß–µ–∫–∞—î–º–æ –ø–æ–∫–∏ –≤—ñ–¥–µ–æ –ø–æ—á–Ω–µ –≤—ñ–¥—Ç–≤–æ—Ä—é–≤–∞—Ç–∏—Å—è, –ø–µ—Ä–µ–¥ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è–º offer
      await new Promise(resolve => {
        video.onloadedmetadata = () => {
          resolve();
        };
      });

      // –°—Ç–≤–æ—Ä—é—î–º–æ offer —ñ –≤—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('offer', room, offer);
    }

    cameraSelect.addEventListener('change', () => {
      startCameraById(cameraSelect.value);
    });

    refreshBtn.addEventListener('click', getCameras);

    socket.on('answer', answer => {
      if (pc) pc.setRemoteDescription(answer);
    });

    socket.on('candidate', candidate => {
      if (pc) pc.addIceCandidate(candidate);
    });

    // –°—Ç–∞—Ä—Ç—É—î–º–æ: –æ—Ç—Ä–∏–º—É—î–º–æ —Å–ø–∏—Å–æ–∫ –∫–∞–º–µ—Ä —ñ –∑–∞–ø—É—Å–∫–∞—î–º–æ –ø–µ—Ä—à—É
    getCameras().then(() => {
      if (cameraSelect.options.length > 0) {
        startCameraById(cameraSelect.options[0].value);
      }
    });
  </script>
</body>
</html>
